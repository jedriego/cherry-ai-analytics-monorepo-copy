## Documentation Guide

### models

| Field | Required | Description |
| ----- | ----- | ----- |
| `description` | Yes | Explain *what the model represents*, and *how itâ€™s used* |
| `columns` | Yes | Every column listed with a clear business-facing description |
| `meta` | No | Something we might want to include in the future; add in owner and SLA information |

### columns

| Field | Required | Description |
| ----- | ----- | ----- |
| `description` | Yes | Explain the purpose of the column, how itâ€™s derived, and any information related to units or nullable values |
| `data_type` | Yes | Can be autogenerated using dbt-codegen (see example below) |

**Notes**

* **Describe purpose of column** (where possible, tie to business-level terms)  
* Include **units and formats** where relevant (e.g., USD, percent, etc)  
* Indicate whether a field is **obfuscated or hashed for PII information**  
* If column is nullable, **explain in what situations itâ€™s null**  
* If categorical, **add in available categories & mapping** if values are not obvious  
  * If list is too long (i.e., \> 5), only include top categories

**Reference guide for standardization** (source \- ChatGPT):

Note \- this does not have to be a hard & fast rule but is intended to be a guide for documentation

| Type | Pattern | Example |
| ----- | ----- | ----- |
| **Booleans (flags)** | `Indicates whether...` or `Boolean flag indicating whether...` | `Indicates whether the order was placed using a promo code.` |
| **Counts** | `Total number of...` | `Total number of items included in the order.` |
| **Dates / Timestamps** | `Date when...`, `Timestamp of...` | `Timestamp when the payment was captured.` |
| **IDs and keys** | `Unique identifier for...` | `Unique identifier for each order.` |
| **Names / Text fields** | `Name of...`, `Label for...`, `Category of...` | `Name of the product as shown in the catalog.` |
| **Enums / Codes** | `Status code representing...`, `Categorical flag for...` | `Categorical flag for the fulfillment method used.` |
| **Aggregates (amounts, sums, etc.)** | `Total amount of...`, `Sum of...`, `Cumulative...` | `Total amount paid by the customer, in USD.` |
| **Percentages / Ratios** | `Proportion of...`, `Percentage of...` | `Percentage of successful payments among all attempts.` |
| **Derived / Calculated** | `Calculated as...`, `Derived from...` | `Derived from the difference between shipped_at and created_at.` |
| **Nullable or optional fields** | `May be null if...` or `Null when...` | `May be null if the user checked out as a guest.` |

### sources

Every source should be documented with:

* `name`, `description`  
* `tables:` and for each:  
  * Table-level `description`  
  * `columns:` with at least the primary key and key business fields

## Tools

### dbt-codegen ([documentation](https://github.com/dbt-labs/dbt-codegen/tree/0.13.1/#create_base_models-source))

**Good for: generating automatic yaml file to copy & paste into a yaml file**

Additional documentation in [dbt blogpost](https://docs.getdbt.com/blog/generating-dynamic-docs-dbt)

In packages.yml, add:

```
 - package: dbt-labs/codegen
    version: 0.13.1
```

Example usage:  
`dbt run â€“select {{model_name}}`  
`dbt run-operation generate_model_yaml --args '{"model_names": ["{{model_name}}"], "upstream_descriptions": true}'`

Sample output in dbt CLI:

```
version: 2

models:
  - name: daily_active_loans_count
    description: ""
    columns:
      - name: record_date
        data_type: date
        description: "Date of the loan record"

      - name: active_loan_count
        data_type: number
        description: ""

      - name: loans_per_100k
        data_type: number
        description: ""

      - name: new_applicant_cnt
        data_type: number
        description: ""

      - name: existing_borrower_cnt
        data_type: number
        description: ""
```

Note \- make sure to run the dbt model locally first; dbt-codegen uses the information schema to parse the columns. Because we enabled `upstream_descriptions: true` it is able to get the description for record\_date in the above example

**Benefits:** 

* No need to manually input each column  
  * Less prone to human errors  and typos  
  * The only thing that is needed is a description for each value  
* Helps enforce what values are necessary  
* Is able to get upstream definitions  
* Can also generate source using `generate_source` command instead

**Possible followups:**

1. Add in dbt-codegen to GitHub Actions, fails if yaml does not exist for the model & automatically generate a yaml stub

## Doc blocks ([documentation](https://docs.getdbt.com/docs/build/documentation#using-docs-blocks))

[In depth dbt blog post](https://docs.getdbt.com/blog/generating-dynamic-docs-dbt#create-docs-blocks-for-the-new-columns)

**Good for: longer descriptions; reusing descriptions using Jinja macros within the same folders**

Example usage:

In a .md file, add in:

```
{% docs activity_based_interest__id %}  

The internal company id for a given user.

{% enddocs %}
```

And reference in yaml file as:

```
   columns:
      - name: id
        description: "{{ doc('activity_based_interest__id') }}"
```

[This](https://docs.getdbt.com/blog/generating-dynamic-docs-dbt#get-all-unique-columns-within-the-folder) goes into further depths on how to automate the activity if you have a lot of copy & paste going onâ€¦

## Future followups

- [ ] Explore dbt-checkpoint ([https://github.com/dbt-checkpoint/dbt-checkpoint](https://github.com/dbt-checkpoint/dbt-checkpoint))  
- [ ] Add dbt-codegen to GitHub Actions and fail if a yaml file does not exist for the model, auto generates a yaml stub  
- [ ] Add PR template, e.g.,

```
## ðŸ“˜ dbt Documentation Checklist

- [ ] Model-level description explains purpose and grain
- [ ] Each column has a business-facing description
- [ ] `meta.owner` and SLA are present
- [ ] Sources (if any) have description and column docs
- [ ] dbt docs was previewed locally (`dbt docs serve`)

```

